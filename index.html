<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/x-icon" href="/img/aiquokka.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&family=Noto+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"
        rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            display: flex;
            flex-direction: column;
            margin: 0;
            background-color: #F3F4F6;

            font-family: 'Noto Sans', sans-serif;
            font-size: 15px;
        }

        .emoji {
            font-family: 'Noto Color Emoji', sans-serif;
        }

        h1,
        h2 {
            margin: 0;
        }

        #loading {
            position: fixed;
            top: 30vh;
            width: 100%;
            text-align: center;
            margin: 0;
            padding: 1em 0;
            background: repeating-linear-gradient(-45deg, #606dbc, #606dbc 10px, #465298 10px, #465298 20px);
            color: white;
        }

        div.content {
            flex: 1 auto;
        }

        div.main {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 100%;
            padding: 0.5em;
        }

        #answer {
            display: flex;
            flex-direction: column;
            flex: 1 100px;
            /* for arrows */
            padding: 0 8px;
            overflow: auto;
        }

        #answer .chat-bubble {
            position: relative;
            max-width: 90%;
            margin: 2px;
            margin-bottom: 1em;
            padding: 10px;
            border-radius: 5px;
            background-color: #b7d3e1;
            box-shadow: 2px 2px 2px 2px #e5e5e5;
        }

        #answer .chat-bubble::after {
            content: '';
            position: absolute;
            width: 0px;
            height: 0px;
            top: 4px;
            border: 10px solid transparent;
        }

        #answer .chat-bubble.assistant {
            padding-left: 6px;
            align-self: flex-start;
        }

        #answer .chat-bubble.assistant::after {
            left: -10px;
            border-right-color: #b7d3e1;
            border-left: 0;
        }

        #answer .chat-bubble.user {
            padding-left: 2px;
            align-self: flex-end;
            background-color: #b7bde1;
        }

        #answer .chat-bubble.user::after {
            right: -10px;
            border-left-color: #b7bde1;
            border-right: 0;
        }

        #answer .chat-bubble::before {
            position: relative;
            bottom: 8px;
            margin-right: 0.5em;
            font-size: 0.8em;
        }

        #answer .chat-bubble.user::before {
            content: 'üë§';
        }

        #answer .chat-bubble.assistant::before {
            content: 'ü§ñ AI';
        }

        #answer img {
            max-width: 100%;
        }

        #answer .tokens-usage {
            margin: 0;
            margin-left: 8px;
            font-size: 0.8em;
            font-style: italic;
        }

        #answer .message-suffix {
            float: right;
            font-size: 0.8em;
            font-style: italic;
        }

        header {
            display: flex;
            align-items: center;
        }

        header button {
            background: none;
            border: none;
            font-size: 1.3em;
            padding: 0.5em 0.7em;
            cursor: pointer;
        }

        header button:hover {
            background-color: #e4e4e4;
        }

        header #chatName {
            margin-right: auto;
        }

        .sidebar {
            position: fixed;
            top: 0;
            left: -40vw;
            width: 40vw;
            height: 100vh;
            overflow: auto;
            background-color: #e3e3e3;
            border-right: 2px solid #d9d9d9;
            transition: left 0.3s ease-in-out;
        }

        .sidebar-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #0e0e0e6e;
            cursor: pointer;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-overlay.open {
            display: block;
        }

        .login {
            border: 1px dashed #ccc;
            padding: 0.5em;
        }

        .params {
            display: flex;
            flex-wrap: wrap;
        }

        .params label {
            margin-left: 0.5em;
        }

        .params>div {
            width: 50%;
        }

        .params input[type="number"] {
            width: 6em;
        }

        .inputs {
            display: flex;
        }

        .inputs #mainInput {
            flex: 1 20em;
            min-height: 10em;
            max-height: 10em;
        }

        .inputs button {
            flex-basis: 1em;
            align-self: center;
            margin: 0 0 0 0.2em;
            font-size: 3em;
            padding: 0;
            border-radius: 8px;
            border-width: 3px;
            border-color: #f3f4f6;
        }

        .inputs button:hover {
            background-color: #e4e4e4;
        }

        #chatsHistory p {
            margin: 0.4em;
            padding: 1em 0.6em;
            cursor: pointer;
            background: #b7d3e1;
            border-radius: 8px;
        }

        #chatsHistory p:hover {
            background-color: #b7bde1;
        }

        #chatsHistory p button {
            float: right;
            line-height: 2em;
            padding: 0.2em 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        #chatsHistory p button:hover {
            background-color: #e4e4e4;
        }

        select {
            width: 10em;
        }

        /* Responsive styles */
        @media screen and (max-width: 1024px) {
            header h1 {
                font-size: 1.6em;
            }

            .params>div {
                width: 100%;
            }

            .params input[type="range"] {
                width: 90%;
            }
        }

        @media screen and (max-width: 800px) {
            header div h1 {
                display: none;
            }

            header div h1+q {
                display: none;
            }

            header>h1 {
                font-size: 1.6em;
                line-height: 1.9em;
            }

            #answer .tokens-usage .usage {
                display: block;
            }

            .sidebar {
                width: 70vw;
                left: -70vw;
            }

            .inputs #mainInput {
                min-height: 4em;
                max-height: 8em;
            }

            .inputs button {
                font-size: 2em;
            }
        }
    </style>
    <title>AI Quokka, Yet Another OpenAI API client</title>
</head>

<body onload="init()">
    <header>
        <button class="emoji" onclick="toggleSidebar()" title="Display settings">‚ò∞</button>
        <h1 id="chatName"></h1>
        <div>
            <h1><img src="img/aiquokka.png" style="height: 1em;" /> AI Quokka, Yet Another OpenAI API client</h1>
            <q><em>...for Quokkas are known for their cheerful demeanor</em> - ChatGPT 3.5</q>
        </div>
    </header>
    <div class="content">
        <div class="main">
            <div id="answer"></div>
            <div class="inputs">
                <textarea id="mainInput" autofocus
                    oninput="this.style.height=''; this.style.height=this.scrollHeight + 'px'"></textarea>
                <button class="emoji" id="chat" onclick="sendChat()" title="Send message to chat">üí¨</button>
                <button class="emoji" id="image" onclick="generateImage()" title="Generate image">üåÑ</button>
            </div>
        </div>
    </div>
    <div class="sidebar-overlay" onclick="toggleSidebar()"></div>
    <div class="sidebar">
        <div class="login">
            <label for="userSelect">Select user</label>
            <select id="userSelect" name="userSelect" onchange="setCurrentUser();">
            </select>
            <button class="emoji" onclick="addUser();">‚ú® Add user</button>
            <button class="emoji" onclick="clearUsers()">üóëÔ∏è Clear users</button>
        </div>
        <h1>
            Parameters
            <sup style="font-size: 0.5em;">
                <a href="https://platform.openai.com/docs/api-reference/chat/create" target="_blank">
                    API reference
                </a>
            </sup>
        </h1>
        <h2>Chat</h2>
        <div class="params">
            <div>
                <label for="chatModelSelect">Chat Model</label>
                <select id="chatModelSelect" name="chatModelSelect">
                    <option value="gpt-4-turbo-preview">gpt-4-turbo-preview</option>
                    <option value="gpt-4">gpt-4</option>
                    <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                    <option value="gpt-4-vision-preview">gpt-4-vision-preview</option>
                    <option value="gpt-4-32k">gpt-4-32k</option>
                </select>
            </div>
            <div>
                <label for="temperatureInput"
                    title="Controls randomness: Lowering results in less random completions. As the temperature approaches zero, the model will become deterministic and repetitive.">
                    Temperature:
                </label>
                <input type="number" id="temperatureValue" value="1" />
                <input type="range" id="temperatureInput" min="0" max="2" step="0.01" value="1" />
            </div>
            <div>
                <label for="tokensLimitInput">Completion limit</label>
                <input type="number" id="tokensLimitInput" name="tokensLimitInput" value="1024" />
            </div>
            <div>
                <label for="topPInput"
                    title="Controls diversity via nucleus sampling: 0.5 means half of all likelihood-weighted options are considered.">
                    Top P:
                </label>
                <input type="number" id="topPValue" value="1" />
                <input type="range" id="topPInput" min="0" max="1" step="0.01" value="1" />
            </div>
            <div>
                <label for="frequencyPenaltyInput"
                    title="How much to penalize new tokens based on their existing frequency in the text so far. Decreases the model's likelihood to repeat the same line verbatim.">
                    Frequency penalty:
                </label>
                <input type="number" id="frequencyPenaltyValue" value="0" />
                <input type="range" id="frequencyPenaltyInput" min="0" max="2" step="0.01" value="0" />
            </div>
            <div>
                <label for="presencePenaltyInput"
                    title="How much to penalize new tokens based on whether they appear in the text so far. Increases the model's likelihood to talk about new topics.">
                    Presence penalty:
                </label>
                <input type="number" id="presencePenaltyValue" value="0" />
                <input type="range" id="presencePenaltyInput" min="0" max="2" step="0.01" value="0" />
            </div>
            <div>
                <label for="seedInput">Seed (beta):</label>
                <input type="number" id="seedInput" value="" />
            </div>
        </div>
        <h2>Image</h2>
        <div class="params">
            <div>
                <label for="imageModelSelect">Image Model</label>
                <select id="imageModelSelect" name="imageModelSelect">
                    <option value="dall-e-3">dall-e-3</option>
                    <option value="dall-e-2">dall-e-2</option>
                </select>
            </div>
            <div>
                <label for="imageSizeSelect">Image Size</label>
                <select id="imageSizeSelect" name="imageSizeSelect">
                    <option value="1024x1024">1024x1024</option>
                    <option value="1024x1792">1024x1792 (Dall-e 3)</option>
                    <option value="1792x1024">1792x1024 (Dall-e 3)</option>
                    <option value="512x512">512x512 (Dall-e 2)</option>
                    <option value="256x256">256x256 (Dall-e 2)</option>
                </select>
            </div>
            <div>
                <label for="imageDisableRevisedPromptCb">Disable revised prompt (Dall-e 3)</label>
                <input type="checkbox" id="imageDisableRevisedPromptCb" name="imageDisableRevisedPromptCb" />
            </div>
        </div>
        <h1>Your conversations</h1>
        <div id="chatsHistory"></div>
    </div>
    <h2 id="loading" style="visibility: hidden;">Loading...</h2>

    <script>
        'use strict';

        const localStorageUsersKey = 'localStorageUsersKey';
        let users = null;
        let currentUser = null;

        let db = null;
        let currentChat = null;
        let chatRenderer = null;

        let userSelect = null;
        let loadingElement = null;
        let mainInput = null;
        let answerDiv = null;
        let chatsHistoryContainer = null;
        let chatNameHeader = null;
        let tokensLimitInput = null;
        let chatModelSelect = null;
        let temperatureInput = null;
        let topPInput = null;
        let frequencyPenaltyInput = null;
        let presencePenaltyInput = null;
        let seedInput = null;

        const QuokkaMessageTypes = {
            chat: 'chat',
            image: 'image'
        };

        class QuokkaMessage {
            constructor(role, content, type) {
                this.role = role;
                this.content = content;
                this.type = type;
            }

            toOpenAIModel() {
                return {
                    role: this.role,
                    content: this.content
                };
            }
        }

        class QuokkaChat {
            #observers = [];
            constructor(id, name, conversationHistory) {
                if (id) {
                    this.id = id;
                }
                this.name = name || '*New chat*';
                this.conversationHistory = conversationHistory || [];
            }

            addMessage(role, content, type, suffix) {
                const newMessage = new QuokkaMessage(role, content, type);
                this.conversationHistory.push(newMessage);
                saveCurrentChat(); // TODO move
                this.#observers.forEach(o => o.messageAdded?.(newMessage, suffix));
            }

            subscribe(observer) {
                this.#observers.push(observer);
            }
        }

        class QuokkaChatRenderer {
            #chat = null;
            #answerDiv = null;

            constructor(chat, answerDiv) {
                this.#chat = chat;
                this.#answerDiv = answerDiv;

                this.#chat.subscribe(this);

                this.renderChat();
            }

            messageAdded(message, suffix) {
                this.renderMessage(message, suffix); // TODO refactor suffix into message
            }

            renderChat() {
                this.#answerDiv.innerHTML = '';
                this.#chat.conversationHistory?.forEach(ch => {
                    renderMessage(ch);
                });
                setTimeout(() => {
                    this.#answerDiv.scrollTop = this.#answerDiv.scrollHeight;
                });
            }

            renderMessage(message, suffix) {
                renderMessage(message, suffix);
                setTimeout(() => {
                    this.#answerDiv.scrollTop = this.#answerDiv.scrollHeight;
                });
            }
        }

        function init() {
            userSelect = document.getElementById('userSelect');
            loadingElement = document.getElementById('loading');
            mainInput = document.getElementById('mainInput');
            answerDiv = document.getElementById('answer');
            chatsHistoryContainer = document.getElementById('chatsHistory');
            chatNameHeader = document.getElementById('chatName');
            tokensLimitInput = document.getElementById('tokensLimitInput');
            chatModelSelect = document.getElementById('chatModelSelect');
            temperatureInput = document.getElementById('temperatureInput');
            topPInput = document.getElementById('topPInput');
            frequencyPenaltyInput = document.getElementById('frequencyPenaltyInput');
            presencePenaltyInput = document.getElementById('presencePenaltyInput');
            seedInput = document.getElementById('seedInput');

            currentChat = new QuokkaChat();
            chatRenderer = new QuokkaChatRenderer(currentChat, answerDiv);

            users = JSON.parse(localStorage.getItem(localStorageUsersKey)) ?? [];

            handleEvents();

            updateUsers();
            renderChatName(); // TODO move to QuokkaChatRenderer?

            const conn = indexedDB.open('quokkaDb', 2);

            conn.onupgradeneeded = (e) => {
                db = conn.result;
                const oldVersion = e.oldVersion;

                console.log(`Upgrading IndexedDB from oldVersion ${oldVersion} to version ${db.version}`);

                if (oldVersion < 1) {
                    // Initial schema
                    db.createObjectStore('chats', { keyPath: 'id' });
                    console.log('IndexedDB schema v1 applied');
                }

                if (oldVersion < 2) { // v1 -> v2
                    db.deleteObjectStore('chats');
                    db.createObjectStore('chats', { keyPath: 'id', autoIncrement: true });
                    console.log('IndexedDB schema v2 applied, all data wiped, no migration');
                }

                if (oldVersion < 3) { // v2 -> v3
                    //TODO //const index = store.createIndex
                }
            };

            conn.onsuccess = () => {
                db = conn.result;
                console.log('IndexedDB opened successfully, conversations will be recorded');

                renderChatsHistory();
            };

            conn.onerror = (e) => {
                console.error("IndexedDB opening failed, some functionality may be broken!", e);
                alert("Failed to open IndexedDB, see console");
            };
        }

        function sendChat() {
            if (!currentUser) {
                alert('No user selected');
                return;
            }

            const prompt = mainInput.value;
            currentChat.addMessage('user', prompt, QuokkaMessageTypes.chat);

            const apiUrl = 'https://api.openai.com/v1/chat/completions';
            const requestData = {
                model: chatModelSelect.value,
                messages: currentChat.conversationHistory
                    .filter(m => m.type !== QuokkaMessageTypes.image)
                    .map(m => m.toOpenAIModel()),
                temperature: +temperatureInput?.value || 1,
                max_tokens: +tokensLimitInput?.value || 1024,
                top_p: +topPInput?.value || 1,
                frequency_penalty: +frequencyPenaltyInput?.value || 0,
                presence_penalty: +presencePenaltyInput?.value || 0,
                seed: +seedInput?.value || null,
            };
            const headers = {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentUser.openAIToken}`,
            };

            setLoading(true);
            fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestData),
            })
                .then((response) => response.json())
                .then((data) => {
                    console.log(data);

                    const tokensUsedParagraph = document.createElement('p');
                    tokensUsedParagraph.classList.add('tokens-usage');
                    tokensUsedParagraph.innerHTML += `<span class="model">Model: ${data.model}. </span>`;
                    tokensUsedParagraph.innerHTML += `<span class="usage">Tokens usage: ‚úîÔ∏ècompletion: ${data.usage.completion_tokens} ‚ùîprompt: ${data.usage.prompt_tokens} üü∞total: ${data.usage.total_tokens}</span>`;
                    answerDiv.append(tokensUsedParagraph);

                    data?.choices?.forEach(choice => {
                        currentChat.addMessage(choice?.message?.role, choice?.message?.content, QuokkaMessageTypes.chat, `Finish reason: ${choice?.finish_reason}`);
                    });
                    mainInput.value = '';
                })
                .catch((error) => {
                    alert('An error occured, see console');
                    console.error('Error:', error);
                }).finally(() => {
                    setLoading(false);
                });
        }

        function generateImage() {
            if (!currentUser) {
                alert('No user selected');
                return;
            }

            const imageModelSelect = document.getElementById('imageModelSelect');
            const imageSizeSelect = document.getElementById('imageSizeSelect');
            const imageDisableRevisedPromptCb = document.getElementById('imageDisableRevisedPromptCb');

            let prompt = mainInput.value;
            if (imageDisableRevisedPromptCb.checked) {
                // "disabling" from the docs
                prompt = 'I NEED to test how the tool works with extremely simple prompts. DO NOT add any detail, just use it AS-IS: ' + prompt;
            }

            currentChat.addMessage('user', prompt, QuokkaMessageTypes.image);

            const apiUrl = 'https://api.openai.com/v1/images/generations';
            const requestData = {
                model: imageModelSelect.value,
                prompt: prompt,
                n: 1,
                size: imageSizeSelect.value,
                response_format: 'b64_json' // we have to use this format since fetch by URL is blocked by CORS when read by javascript
            };
            const headers = {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentUser.openAIToken}`,
            };

            setLoading(true);
            fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestData),
            })
                .then((response) => response.json())
                .then((response) => {
                    console.log(response);

                    response?.data?.forEach(img => {
                        const blob = convertBase64ToBlob(img.b64_json, 'image/png');

                        currentChat.addMessage('assistant', blob, QuokkaMessageTypes.image);
                        if (img.revised_prompt) {
                            currentChat.addMessage('assistant', `Revised prompt: <em>${img.revised_prompt}</em>`, QuokkaMessageTypes.image);
                        }
                    });
                    mainInput.value = '';
                })
                .catch((error) => {
                    console.error('Error:', error);
                }).finally(() => {
                    setLoading(false);
                });
        }

        function convertBase64ToBlob(base64, type) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: type });
        }

        function renderMessage(message, suffix) {
            const { role, content = '', type } = message || {};

            if (!role) {
                console.warn('Invalid message, missing role', message);
                return;
            }

            const answerParagraph = document.createElement('p');
            answerParagraph.classList.add('chat-bubble', role);
            if (type === QuokkaMessageTypes.image && role === 'assistant' && content instanceof Blob) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(content);
                answerParagraph.append(img);
            } else {
                answerParagraph.innerHTML += content.replace(/\n/g, '<br />');
            }
            if (suffix) {
                answerParagraph.innerHTML += `<br /><span class="message-suffix">${suffix}</span>`;
            }
            answerDiv.append(answerParagraph);
        }

        function addUser() {
            const name = prompt('Name?');
            const openAIToken = prompt('OpenAI token?');

            users = [...users, { name: name, openAIToken: openAIToken }];
            updateUsers();
        }

        function clearUsers() {
            users = [];
            updateUsers();
        }

        function updateUsers() {
            localStorage.setItem(localStorageUsersKey, JSON.stringify(users));
            renderUsers();

            setCurrentUser();
        }

        function setCurrentUser() {
            currentUser = users.find(u => u.name === userSelect.value);
        }

        function renderUsers() {
            userSelect.innerHTML = '';

            users?.forEach(u => {
                userSelect.innerHTML += `<option value="${u.name}">${u.name}</option>`;
            });
        }

        function renderChatsHistory() {
            chatsHistoryContainer.innerHTML = '';

            const t = db.transaction('chats', 'readonly');
            const store = t.objectStore('chats');

            const query = store.getAll();
            query.onsuccess = () => {
                query.result?.forEach(ch => {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('emoji');
                    deleteBtn.innerText = '‚ùå';
                    deleteBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); onChatHistoryDelete(ch); return false; };

                    const chatHistoryPar = document.createElement('p');
                    const numberOfMessages = ch?.conversationHistory?.filter(m => m.type === QuokkaMessageTypes.chat)?.length;
                    const numberOfImages = ch?.conversationHistory?.filter(m => m.type === QuokkaMessageTypes.image)?.length;
                    chatHistoryPar.innerHTML = `${ch.id}: <span>${ch.name} (${numberOfMessages} messages, ${numberOfImages} image messages)</span>`;
                    chatHistoryPar.append(deleteBtn);
                    chatHistoryPar.onclick = () => { onChatHistorySelect(ch); };

                    chatsHistoryContainer.append(chatHistoryPar);
                });
            };
            query.onerror = (e) => {
                console.error('Failed to get chats history from IndexedDB', error);
                alert('Failed to get chats history from IndexedDB, see console');
            };
        }

        function renderChatName() {
            chatNameHeader.innerText = currentChat.name;
        }

        function onChatHistorySelect(chatHistoryItem) {
            toggleSidebar();
            currentChat = new QuokkaChat(
                chatHistoryItem.id,
                chatHistoryItem.name,
                chatHistoryItem.conversationHistory?.map(m => new QuokkaMessage(m.role, m.content, m.type))
            );
            chatRenderer = new QuokkaChatRenderer(currentChat, answerDiv);
            renderChatName();
        }

        function onChatHistoryDelete(chatHistoryItem) {
            if (!chatHistoryItem?.id) {
                renderChatsHistory();
                return;
            }

            if (!confirm(`Are you sure you want to delete chat ${chatHistoryItem.name} (id: ${chatHistoryItem.id})?`)) {
                return;
            }

            const t = db.transaction('chats', 'readwrite');
            const store = t.objectStore('chats');

            const query = store.delete(chatHistoryItem.id);
            query.onsuccess = () => {
                console.warn(`Chat Id ${chatHistoryItem.id} deleted`, chatHistoryItem);
                renderChatsHistory();
            };
            query.onerror = (e) => {
                console.error('Failed to delete chat from IndexedDB', error);
                alert('Failed to delete chat from IndexedDB, see console');
            };
        }

        function saveCurrentChat() {
            if (!currentChat) {
                return;
            }

            if (!currentChat.id || currentChat.id <= 0) {
                //new chat, save
                const name = prompt('Provide name for this chat please');
                currentChat.name = name;
                renderChatName();
            }

            const t = db.transaction('chats', 'readwrite');
            const store = t.objectStore('chats');

            const saveQuery = store.put(currentChat);

            saveQuery.onsuccess = (event) => {
                currentChat.id = saveQuery.result;
                console.log(`Chat Id ${currentChat.id} saved`, currentChat);

                renderChatsHistory();
            };
            saveQuery.onerror = (e) => {
                console.error('Failed to save chat into IndexedDB', e);
                alert('Failed to save chat into IndexedDB, see console');
            };
        }

        function toggleSidebar() {
            renderChatsHistory();
            document.querySelector(".sidebar").classList.toggle("open");
            document.querySelector(".sidebar-overlay").classList.toggle("open");
        }

        function setLoading(isLoading) {
            loadingElement.style.visibility = isLoading ? 'visible' : 'hidden';
            mainInput.disabled = isLoading;
        }

        function handleEvents() {
            document.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.key == "Enter") {
                    sendChat();
                }
            });

            handleRangeSlide(temperatureInput, 'temperatureValue');
            handleRangeSlide(topPInput, 'topPValue');
            handleRangeSlide(frequencyPenaltyInput, 'frequencyPenaltyValue');
            handleRangeSlide(presencePenaltyInput, 'presencePenaltyValue');

            handleSwipe(document.body, (distance) => {
                // swipe right
                if (distance > 100) {
                    toggleSidebar();
                }

                // swipe left
                if (distance < -100) {
                    toggleSidebar();
                }
            });

            handleSwipe(mainInput, (distance, event) => {
                // swipe right
                if (distance > 100) {
                    sendChat();
                    event.stopPropagation();
                }
            });
        }

        function handleRangeSlide(rangeInput, valueInputId) {
            rangeInput.oninput = () => {
                document.getElementById(valueInputId).value = rangeInput.value;
            };
        }

        function handleSwipe(targetElement, callback) {
            let touchStartX = 0;
            let touchEndX = 0;

            targetElement.addEventListener('touchstart', (event) => {
                touchStartX = event.changedTouches?.[0]?.screenX;
                touchEndX = touchStartX; // prevent issue with taps, no touchmove event
            });

            targetElement.addEventListener('touchmove', (event) => {
                touchEndX = event.changedTouches?.[0]?.screenX;
            }, { passive: true });

            targetElement.addEventListener('touchend', (event) => {
                const distance = touchEndX - touchStartX; // warning: NaN if no changedTouches
                callback(distance, event);
            });
        }
    </script>

</body>

</html>