<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/x-icon" href="/img/aiquokka.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&family=Noto+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"
        rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            display: flex;
            flex-direction: column;
            margin: 0;
            background-color: #F3F4F6;

            font-family: 'Noto Sans', sans-serif;
            font-size: 15px;
        }

        .emoji {
            font-family: 'Noto Color Emoji', sans-serif;
        }

        h1,
        h2 {
            margin: 0;
        }

        #loading {
            position: fixed;
            top: 30vh;
            width: 100%;
            text-align: center;
            margin: 0;
            padding: 1em 0;
            background: repeating-linear-gradient(-45deg, #606dbc, #606dbc 10px, #465298 10px, #465298 20px);
            color: white;
        }

        div.content {
            flex: 1 auto;
        }

        div.main {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 100%;
            padding: 0.5em;
        }

        #answer {
            display: flex;
            flex-direction: column;
            flex: 1 100px;
            /* for arrows */
            padding: 0 8px;
            overflow: auto;
        }

        #answer .chat-bubble {
            position: relative;
            max-width: 90%;
            margin: 2px;
            margin-bottom: 1em;
            padding: 10px;
            border-radius: 5px;
            background-color: #b7d3e1;
            box-shadow: 2px 2px 2px 2px #e5e5e5;
        }

        #answer .chat-bubble::after {
            content: '';
            position: absolute;
            width: 0px;
            height: 0px;
            top: 4px;
            border: 10px solid transparent;
        }

        #answer .chat-bubble.assistant {
            padding-left: 6px;
            align-self: flex-start;
        }

        #answer .chat-bubble.assistant::after {
            left: -10px;
            border-right-color: #b7d3e1;
            border-left: 0;
        }

        #answer .chat-bubble.user {
            padding-left: 2px;
            align-self: flex-end;
            background-color: #b7bde1;
        }

        #answer .chat-bubble.user::after {
            right: -10px;
            border-left-color: #b7bde1;
            border-right: 0;
        }

        #answer .chat-bubble.system,
        #answer .chat-bubble.tool {
            align-self: center;
            min-width: 94%;
            text-align: center;
            background-color: #e3e3e3;
        }

        #answer .chat-bubble::before {
            position: relative;
            bottom: 8px;
            margin-right: 0.5em;
            font-size: 0.8em;
        }

        #answer .chat-bubble.user::before {
            content: 'üë§';
        }

        #answer .chat-bubble.user.image::before {
            content: 'üë§üñºÔ∏è';
        }

        #answer .chat-bubble.assistant::before {
            content: 'ü§ñ AI';
        }

        #answer .chat-bubble.assistant.toolCall::before {
            content: 'üõ†Ô∏è AI';
        }

        #answer .chat-bubble.tool::before {
            content: 'üõ†Ô∏èüë§';
        }

        #answer .chat-bubble.system::before {
            content: 'üíª';
        }

        #answer img {
            max-width: 100%;
        }

        #answer .metadata {
            margin: 0;
            margin-left: 8px;
            font-size: 0.8em;
            font-style: italic;
        }

        #answer .message-suffix {
            float: right;
            font-size: 0.8em;
            font-style: italic;
        }

        header {
            display: flex;
            align-items: center;
        }

        header button {
            background: none;
            border: none;
            font-size: 1.3em;
            padding: 0.5em 0.7em;
            cursor: pointer;
        }

        header button:hover {
            background-color: #e4e4e4;
        }

        header .chat-name {
            margin-right: auto;
        }

        header input {
            font-size: 1em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            background: none;
            font-family: inherit;
        }

        header input:hover {
            background: #e4e4e4;
        }

        header input:focus {
            outline: none;
            background: #e4e4e4;
        }

        .sidebar {
            position: fixed;
            top: 0;
            left: -40vw;
            width: 40vw;
            height: 100vh;
            overflow: auto;
            background-color: #e3e3e3;
            border-right: 2px solid #d9d9d9;
            transition: left 0.3s ease-in-out;
        }

        .sidebar-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #0e0e0e6e;
            cursor: pointer;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-overlay.open {
            display: block;
        }

        .login {
            border: 1px dashed #ccc;
            padding: 0.5em;
        }

        .params {
            display: flex;
            flex-wrap: wrap;
        }

        div.sidebar>*:last-child {
            /* fix for physical phones */
            padding-bottom: 8em;
        }

        div.sidebar .version {
            text-align: right;
            font-size: 0.8em;
            margin-top: 1em;
        }

        .params label {
            margin-left: 0.5em;
        }

        .params>div {
            width: 50%;
        }

        .params input[type="number"] {
            width: 6em;
        }

        .inputs {
            display: flex;
        }

        .inputs #mainInput {
            flex: 1 20em;
            min-height: 10em;
            max-height: 10em;
        }

        .inputs>div {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .inputs div.actions {
            display: flex;
        }

        .inputs button {
            margin: 0 0 0 0.2em;
            font-size: 3em;
            padding: 0;
            border-radius: 8px;
            border-width: 3px;
            border-color: #f3f4f6;
        }

        .inputs button:hover {
            background-color: #e4e4e4;
        }

        .inputs button#messageRoleSwitcher {
            font-size: 1em;
            padding: 0.2em 0.5em;
        }

        /* Tools styles */
        #toolsList>div {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-end;
            margin: 1em;
        }

        #toolsList>div input[type="text"] {
            flex-grow: 1;
        }

        #toolsList>div input:nth-child(2) {
            font-weight: bold;
        }

        #toolsList>div textarea {
            width: 100%;
        }

        /* Chat history styles */
        #chatsHistory p {
            margin: 0.4em;
            padding: 1em 0.6em;
            cursor: pointer;
            background: #b7d3e1;
            border-radius: 8px;
        }

        #chatsHistory p:hover {
            background-color: #b7bde1;
        }

        #chatsHistory p button {
            float: right;
            line-height: 2em;
            padding: 0.2em 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        #chatsHistory p button:hover {
            background-color: #e4e4e4;
        }

        #storageStats .usage-bar-background {
            position: relative;
            width: 80%;
            height: 1em;

            margin: 0 auto;
            background-color: lightgrey;
            border-radius: 8px;
            overflow: hidden;
        }

        #storageStats .usage-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
        }

        select {
            width: 10em;
        }

        /* Responsive styles */
        @media screen and (max-width: 1024px) {
            header h1 {
                font-size: 1.6em;
            }

            .params>div {
                width: 100%;
            }

            .params input[type="range"] {
                width: 90%;
            }
        }

        @media screen and (max-width: 800px) {
            h1 {
                font-size: 1.5em;
            }

            h2 {
                font-size: 1.2em;
            }

            header div h1 {
                display: none;
            }

            header div h1+q {
                display: none;
            }

            header>h1 {
                font-size: 1.6em;
                line-height: 1.9em;
            }

            #answer .metadata .usage {
                display: block;
            }

            .sidebar {
                width: 70vw;
                left: -70vw;
            }

            .inputs #mainInput {
                min-height: 4em;
                max-height: 8em;
            }

            .inputs button {
                font-size: 2em;
            }
        }
    </style>
    <title>AI Quokka, Yet Another OpenAI API client</title>
</head>

<body onload="init()">
    <header>
        <button class="emoji" onclick="toggleSidebar()" title="Display settings">‚ò∞</button>
        <h1 class="chat-name"><input id="chatNameInput" type="text" oninput="currentChat.name = this.value;" /></h1>
        <div>
            <h1><img src="img/aiquokka.png" style="height: 1em;" /> AI Quokka, Yet Another OpenAI API client</h1>
            <q><em>...for Quokkas are known for their cheerful demeanor</em> - ChatGPT 3.5</q>
        </div>
    </header>
    <div class="content">
        <div class="main">
            <div id="answer"></div>
            <div class="inputs">
                <textarea id="mainInput" autofocus
                    oninput="this.style.height=''; this.style.height=this.scrollHeight + 'px'"></textarea>
                <div>
                    <button id="messageRoleSwitcher" onclick="toggleMessageRole()"
                        title="Next mesage will be under role 'User'">U</button>
                    <div class="actions">
                        <button class="emoji" id="chat" onclick="sendChat()" title="Send message to chat">üí¨</button>
                        <button class="emoji" id="image" onclick="generateImage()" title="Generate image">üåÑ</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="sidebar-overlay" onclick="toggleSidebar()"></div>
    <div class="sidebar">
        <div class="login">
            <label for="userSelect">Select user</label>
            <select id="userSelect" name="userSelect" onchange="setCurrentUser();">
            </select>
            <button class="emoji" onclick="addUser();">‚ú® Add user</button>
            <button class="emoji" onclick="deleteUser()">üö´ Delete</button>
            <button class="emoji" onclick="clearUsers()">üóëÔ∏è Clear all</button>
        </div>
        <h1>
            Parameters
            <sup style="font-size: 0.5em;">
                <a href="https://platform.openai.com/docs/api-reference/chat/create" target="_blank">
                    API reference
                </a>
            </sup>
        </h1>
        <h2>Chat</h2>
        <div class="params">
            <div>
                <label for="chatModelSelect">Chat Model</label>
                <select id="chatModelSelect" name="chatModelSelect">
                </select>
            </div>
            <div>
                <label for="temperatureInput"
                    title="Controls randomness: Lowering results in less random completions. As the temperature approaches zero, the model will become deterministic and repetitive.">
                    Temperature:
                </label>
                <input type="number" id="temperatureValue" value="1" />
                <input type="range" id="temperatureInput" min="0" max="2" step="0.01" value="1" />
            </div>
            <div>
                <label for="tokensLimitInput">Completion limit</label>
                <input type="number" id="tokensLimitInput" name="tokensLimitInput" value="1024" />
            </div>
            <div>
                <label for="topPInput"
                    title="Controls diversity via nucleus sampling: 0.5 means half of all likelihood-weighted options are considered.">
                    Top P:
                </label>
                <input type="number" id="topPValue" value="1" />
                <input type="range" id="topPInput" min="0" max="1" step="0.01" value="1" />
            </div>
            <div>
                <label for="frequencyPenaltyInput"
                    title="How much to penalize new tokens based on their existing frequency in the text so far. Decreases the model's likelihood to repeat the same line verbatim.">
                    Frequency penalty:
                </label>
                <input type="number" id="frequencyPenaltyValue" value="0" />
                <input type="range" id="frequencyPenaltyInput" min="0" max="2" step="0.01" value="0" />
            </div>
            <div>
                <label for="presencePenaltyInput"
                    title="How much to penalize new tokens based on whether they appear in the text so far. Increases the model's likelihood to talk about new topics.">
                    Presence penalty:
                </label>
                <input type="number" id="presencePenaltyValue" value="0" />
                <input type="range" id="presencePenaltyInput" min="0" max="2" step="0.01" value="0" />
            </div>
            <div>
                <label for="seedInput">Seed (beta):</label>
                <input type="number" id="seedInput" value="" />
            </div>
        </div>
        <h2>Image</h2>
        <div class="params">
            <div>
                <label for="imageModelSelect">Image Model</label>
                <select id="imageModelSelect" name="imageModelSelect">
                </select>
            </div>
            <div>
                <label for="imageSizeSelect">Image Size</label>
                <select id="imageSizeSelect" name="imageSizeSelect">
                    <option value="auto">Auto (gpt-image-1)</option>
                    <option value="1024x1024">1024x1024</option>
                    <option value="1024x1792">1024x1792 (Dall-e 3)</option>
                    <option value="1792x1024">1792x1024 (Dall-e 3)</option>
                    <option value="1024x1536">1024x1536 (gpt-image-1)</option>
                    <option value="1536x1024">1536x1024 (gpt-image-1)</option>
                    <option value="512x512">512x512 (Dall-e 2)</option>
                    <option value="256x256">256x256 (Dall-e 2)</option>
                </select>
            </div>
            <div>
                <label for="imageDisableRevisedPromptCb">Disable revised prompt (Dall-e 3)</label>
                <input type="checkbox" id="imageDisableRevisedPromptCb" name="imageDisableRevisedPromptCb" />
            </div>
            <div>
                <label for="imageQualitySelect">Quality</label>
                <select id="imageQualitySelect" name="imageQualitySelect">
                    <option value="">Auto (default)</option>
                    <option value="standard">Standard (Dall-e 2/3)</option>
                    <option value="hd">HD (Dall-e 3)</option>
                    <option value="low">Low (gpt-image-1)</option>
                    <option value="medium">Medium (gpt-image-1)</option>
                    <option value="high">High (gpt-image-1)</option>
                </select>
            </div>
            <div>
                <label for="imageStyleSelect">Style</label>
                <select id="imageStyleSelect" name="imageStyleSelect">
                    <option value="vivid">Vivid (default) (Dall-e 3)</option>
                    <option value="">None (Dall-e 2)</option>
                    <option value="natural">Natural (Dall-e 3)</option>
                </select>
            </div>
            <div>
                <label for="imageOutputFormatSelect">Output Format (gpt-image-1)</label>
                <select id="imageOutputFormatSelect" name="imageOutputFormatSelect">
                    <option value="">Default (png)</option>
                    <option value="png">PNG</option>
                    <option value="jpeg">JPEG</option>
                    <option value="webp">WebP</option>
                </select>
            </div>
            <div>
                <label for="imageBackgroundSelect">Background (gpt-image-1)</label>
                <select id="imageBackgroundSelect" name="imageBackgroundSelect">
                    <option value="">Default (auto)</option>
                    <option value="transparent">Transparent</option>
                    <option value="opaque">Opaque</option>
                </select>
            </div>
            <div>
                <label for="imageCompressionInput">Compression (0-100%, gpt-image-1):</label>
                <input type="number" id="imageCompressionValue" value="100" min="0" max="100" />
                <input type="range" id="imageCompressionInput" min="0" max="100" step="1" value="100" />
            </div>
        </div>
        <h2 title="Tools available in all chats">Global tools</h2>
        <div>
            <button onclick="addTool()">üõ†Ô∏è Add global tool</button>
            <div id="toolsList"></div>
        </div>
        <h1>Your conversations</h1>
        <div id="chatsHistory"></div>
        <div id="storageStats"></div>
        <h1>Import/Export</h1>
        <div class="params">
            <input type="file" id="importFile" accept=".json" />
            <button onclick="importData()">Import</button>
            <button onclick="exportData()">Export</button>
            <span>
                <label for="overwriteChatsCb" title="Overwrite existing chats by Id (checked) or append (unchecked)">
                    Overwrite chats
                </label>
                <input type="checkbox" id="overwriteChatsCb" name="overwriteChatsCb" />
            </span>
        </div>
        <div class="version">v0.1.7</div>
    </div>
    <h2 id="loading" style="visibility: hidden;">Loading...</h2>

    <script>
        'use strict';

        const localStorageUsersKey = 'localStorageUsersKey';
        let users = null;
        let currentUser = null;

        let db = null;
        let currentChat = null;
        let chatRenderer = null;

        let tools = null;
        let builtInTools = null;

        let nextMessageRole = null;

        let userSelect = null;
        let loadingElement = null;
        let mainInput = null;
        let chatsHistoryContainer = null;
        let storageStatsDiv = null;
        let chatNameInput = null;
        let tokensLimitInput = null;
        let chatModelSelect = null;
        let imageModelSelect = null;
        let temperatureInput = null;
        let topPInput = null;
        let frequencyPenaltyInput = null;
        let presencePenaltyInput = null;
        let seedInput = null;
        let versionElement = null;
        let toolsListContainer = null;

        const QuokkaMessageTypes = {
            chat: 'chat',
            image: 'image',
            toolCall: 'toolCall'
        };

        const OpenAiMessageRoles = {
            user: 'user',
            assistant: 'assistant',
            system: 'system',
            tool: 'tool'
        };

        class QuokkaMessage {
            constructor(role, content, type, model, tokenUsage, finishReason, imageOptions, timeStamp, toolCallOptions) {
                this.role = role;
                this.content = content;
                this.type = type;
                this.model = model;
                this.finishReason = finishReason;
                this.timeStamp = timeStamp || null;

                this.tokenUsage = tokenUsage ? {
                    prompt_tokens: tokenUsage.prompt_tokens,
                    completion_tokens: tokenUsage.completion_tokens,
                    total_tokens: tokenUsage.total_tokens
                } : null;

                this.imageOptions = imageOptions ? {
                    size: imageOptions.size,
                    quality: imageOptions.quality
                } : null;

                this.toolCallOptions = toolCallOptions ? {
                    toolCallId: toolCallOptions.toolCallId,
                    type: toolCallOptions.type,
                    name: toolCallOptions.name,
                    arguments: toolCallOptions.arguments
                } : null;
            }

            toOpenAIModel() {
                const result = {
                    role: this.role,
                    content: this.content
                };

                if (this.type === QuokkaMessageTypes.toolCall && this.role === OpenAiMessageRoles.assistant && this.toolCallOptions) {
                    result.tool_calls = [{
                        id: this.toolCallOptions.toolCallId,
                        type: this.toolCallOptions.type,
                        function: {
                            name: this.toolCallOptions.name,
                            arguments: this.toolCallOptions.arguments
                        }
                    }];
                }

                if (this.type === QuokkaMessageTypes.toolCall && this.role === OpenAiMessageRoles.tool && this.toolCallOptions) {
                    result.tool_call_id = this.toolCallOptions.toolCallId;
                }
                return result;
            }
        }

        class QuokkaChat {
            #observers = []; // private to avoid storing in IndexedDB
            constructor(id, name, conversationHistory) {
                if (id) {
                    this.id = id;
                }
                this._name = name || '*New chat*';
                this.conversationHistory = conversationHistory || [];
            }

            get name() {
                return this._name;
            }

            set name(name) {
                this._name = name;
                saveCurrentChat(); // TODO move
                this.#observers.forEach(o => o.nameChanged?.(name));
            }

            addMessage(role, content, type, model, tokenUsage, finishReason, imageOptions, toolCallOptions) {
                if (!this.id || this.id <= 0) {
                    //new chat, get name
                    const name = prompt('Provide name for this chat please, you can change it later');
                    this._name = name;
                    this.#observers.forEach(o => o.nameChanged?.(name));
                }

                const timeStamp = new Date().toISOString(); // consider using server response field "created" instead
                const newMessage = new QuokkaMessage(role, content, type, model, tokenUsage, finishReason, imageOptions, timeStamp, toolCallOptions);
                this.conversationHistory.push(newMessage);
                saveCurrentChat(); // TODO move
                this.#observers.forEach(o => o.messageAdded?.(newMessage));
            }

            subscribe(observer) {
                this.#observers.push(observer);
            }
        }

        class QuokkaCostEstimator {
            // prices below are USD per million tokens
            static #priceListCompletions = [
                { model: /^gpt-4o-mini-[0-9-]*$/, priceIn: 0.15, priceOut: 0.60 },
				{ model: /^gpt-4o-[0-9-]*$/, priceIn: 5, priceOut: 15 },
                { model: /^gpt-4-*[0-9]*-preview$/, priceIn: 10, priceOut: 30 },
                { model: /^gpt-4-*[0-9]*$/, priceIn: 30, priceOut: 60 },
                { model: /^gpt-3.5-turbo-*[0-9]*$/, priceIn: 0.5, priceOut: 1.5 },
                { model: /^gpt-4-vision-preview$/, priceIn: 10, priceOut: 30 },
                { model: /^gpt-4-32k$/, priceIn: 30, priceOut: 60 },
                // for o1 output tokens include internal reasoning tokens generated by the model that are not visible in API responses
                { model: /^o1-preview$/, priceIn: 15, priceOut: 60 },
                { model: /^o1-mini$/, priceIn: 3, priceOut: 12 },
                { model: /^o1$/, priceIn: 15, priceOut: 60 },
                { model: /^o1-[0-9-]*$/, priceIn: 15, priceOut: 60 },
                { model: /^o3-mini$/, priceIn: 1.10, priceOut: 4.40 },
                { model: /^o3-mini-[0-9-]*$/, priceIn: 1.10, priceOut: 4.40 },
                { model: /^gpt-5$/, priceIn: 1.25, priceOut: 10.00 },
                { model: /^gpt-5\.1-[0-9-]*$/, priceIn: 1.25, priceOut: 10.00 },
                { model: /^gpt-5-mini$/, priceIn: 0.25, priceOut: 2.00 },
                { model: /^gpt-5-nano$/, priceIn: 0.05, priceOut: 0.40 },
                { model: /^gpt-5-pro$/, priceIn: 15.00, priceOut: 120.00 },
                { model: /^gpt-4\.1$/, priceIn: 2.00, priceOut: 8.00 },
                { model: /^o3-deep-research$/, priceIn: 10.00, priceOut: 40.00 },
                { model: /^o4-mini-deep-research$/, priceIn: 2.00, priceOut: 8.00 },
                { model: /^o4-mini$/, priceIn: 1.10, priceOut: 4.40 },
                { model: /^gpt-5-codex$/, priceIn: 1.25, priceOut: 10.00 }
            ];

            // prices below are USD per image
            static #priceListImages = [
                { model: 'dall-e-3', quality: 'standard', size: '1024x1024', price: 0.040 },
                { model: 'dall-e-3', quality: 'standard', size: '1024x1792', price: 0.080 },
                { model: 'dall-e-3', quality: 'standard', size: '1792x1024', price: 0.080 },
                { model: 'dall-e-3', quality: 'hd', size: '1024x1024', price: 0.080 },
                { model: 'dall-e-3', quality: 'hd', size: '1024x1792', price: 0.120 },
                { model: 'dall-e-3', quality: 'hd', size: '1792x1024', price: 0.120 },
                { model: 'dall-e-2', quality: 'standard', size: '1024x1024', price: 0.020 },
                { model: 'dall-e-2', quality: 'standard', size: '512x512', price: 0.018 },
                { model: 'dall-e-2', quality: 'standard', size: '256x256', price: 0.016 },
                { model: 'gpt-image-1', quality: 'low', size: '1024x1024', price: 0.011 },
                { model: 'gpt-image-1', quality: 'low', size: '1024x1536', price: 0.016 },
                { model: 'gpt-image-1', quality: 'low', size: '1536x1024', price: 0.016 },
                { model: 'gpt-image-1', quality: 'medium', size: '1024x1024', price: 0.042 },
                { model: 'gpt-image-1', quality: 'medium', size: '1024x1536', price: 0.063 },
                { model: 'gpt-image-1', quality: 'medium', size: '1536x1024', price: 0.063 },
                { model: 'gpt-image-1', quality: 'high', size: '1024x1024', price: 0.167 },
                { model: 'gpt-image-1', quality: 'high', size: '1024x1536', price: 0.25 },
                { model: 'gpt-image-1', quality: 'high', size: '1536x1024', price: 0.25 },
                { model: 'gpt-image-1-mini', quality: 'low', size: '1024x1024', price: 0.005 },
                { model: 'gpt-image-1-mini', quality: 'low', size: '1024x1536', price: 0.006 },
                { model: 'gpt-image-1-mini', quality: 'low', size: '1536x1024', price: 0.006 },
                { model: 'gpt-image-1-mini', quality: 'medium', size: '1024x1024', price: 0.011 },
                { model: 'gpt-image-1-mini', quality: 'medium', size: '1024x1536', price: 0.015 },
                { model: 'gpt-image-1-mini', quality: 'medium', size: '1536x1024', price: 0.015 },
                { model: 'gpt-image-1-mini', quality: 'high', size: '1024x1024', price: 0.036 },
                { model: 'gpt-image-1-mini', quality: 'high', size: '1024x1536', price: 0.052 },
                { model: 'gpt-image-1-mini', quality: 'high', size: '1536x1024', price: 0.052 }
            ];

            static estimateCost(message) {
                try {
                    if (message.type === QuokkaMessageTypes.chat || message.type === QuokkaMessageTypes.toolCall) {
                        return QuokkaCostEstimator.estimateChatCost(message);
                    } else if (message.type === QuokkaMessageTypes.image) {
                        return QuokkaCostEstimator.estimateImageCost(message);
                    }
                } catch (error) {
                    console.error('Failed to estimate cost for message', message, error);
                }
                return null;
            }

            static estimateChatCost(message) {
                if (!message.model || !message.tokenUsage) {
                    return null;
                }

                const model = message.model;
                const inTokens = message.tokenUsage?.prompt_tokens;
                const outTokens = message.tokenUsage?.completion_tokens;

                const priceModel = QuokkaCostEstimator.#priceListCompletions.find(p => model.match(p.model));
                if (!priceModel) {
                    console.warn('No price found for model', model);
                    return null;
                }

                const costIn = priceModel.priceIn * inTokens / 1_000_000;
                const costOut = priceModel.priceOut * outTokens / 1_000_000;

                return {
                    costIn,
                    costOut,
                    costTotal: costIn + costOut
                };
            }

            static estimateImageCost(message) {
                if (!message.model || !message.imageOptions || !message.imageOptions.size) {
                    return null;
                }

                const model = message.model;
                const size = message.imageOptions.size;
                const quality = message.imageOptions.quality ?? 'standard';

                const priceModel = QuokkaCostEstimator.#priceListImages.find(p => p.model === model && p.size === size && p.quality === quality);
                if (!priceModel) {
                    console.warn('No price found for model', model, 'size', size, 'quality', quality);
                    return null;
                }

                return {
                    costIn: null,
                    costOut: priceModel.price,
                    costTotal: priceModel.price
                };
            }
        }

        class QuokkaChatRenderer {
            #chat = null;
            #answerDiv = null;

            #totalCostParagraph = null;

            constructor(answerDiv) {
                this.#answerDiv = answerDiv;
            }

            // Observer methods
            nameChanged(name) {
                this.renderChatName();
            }

            messageAdded(message) {
                this.renderMessage(message);
                this.scrollToBottom();
            }

            // Renderer methods
            selectChat(chat) {
                this.#chat = chat;
                this.#chat.subscribe(this);

                this.renderChatName();
                this.renderChat();
            }

            renderChatName() {
                chatNameInput.value = this.#chat.name;
            }

            renderChat() {
                this.#answerDiv.innerHTML = '';
                this.#chat.conversationHistory?.forEach(ch => {
                    this.renderMessage(ch);
                });
                this.scrollToBottom();
            }

            renderMessage(message) {
                const { role, content = '', type } = message || {};

                if (!role) {
                    console.warn('Invalid message, missing role', message);
                    return;
                }

                this.renderMetadata(message);

                const answerParagraph = document.createElement('p');
                answerParagraph.classList.add('chat-bubble', role, type);
                if (type === QuokkaMessageTypes.image && role === 'assistant' && content instanceof Blob) {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(content);
                    answerParagraph.append(img);
                } else if (type === QuokkaMessageTypes.toolCall && role === 'assistant') {
                    answerParagraph.innerHTML += `Tool call: '${message?.toolCallOptions?.name}' will be called with arguments: ${message?.toolCallOptions?.arguments}`;
                } else if (type === QuokkaMessageTypes.toolCall && role === 'tool') {
                    answerParagraph.innerHTML += `Tool call result: ${content}`;
                } else {
                    answerParagraph.innerHTML += content?.replace(/\n/g, '<br />');
                }
                if (message?.finishReason) {
                    answerParagraph.innerHTML += `<br /><span class="message-suffix">Finish reason: ${message.finishReason}</span>`;
                }
                if (message?.toolCallOptions?.toolCallId) {
                    answerParagraph.innerHTML += `<br /><span class="message-suffix">Tool call ID: ${message.toolCallOptions.toolCallId}</span>`;
                }
                this.#answerDiv.append(answerParagraph);

                this.renderTotalCost();
            }

            renderMetadata(message) {
                if (!message || (!message.tokenUsage && !message.model)) {
                    return;
                }

                const metadataParagraph = document.createElement('p');
                metadataParagraph.classList.add('metadata');

                if (message.model) {
                    metadataParagraph.innerHTML += `<span class="model">Model: ${message.model}. </span>`;
                }

                if (message.tokenUsage) {
                    const completionText = `‚úîÔ∏ècompletion: ${message.tokenUsage.completion_tokens}`;
                    const promptText = `‚ùîprompt: ${message.tokenUsage.prompt_tokens}`;
                    const totalText = `üü∞total: ${message.tokenUsage.total_tokens}`;
                    metadataParagraph.innerHTML += `<span class="usage">Tokens usage: ${completionText} ${promptText} ${totalText}. </span>`;
                }

                if (message.timeStamp) {
                    const timeStamp = message.timeStamp ? new Date(message.timeStamp).toLocaleString() : 'unknown';
                    metadataParagraph.innerHTML += `<span class="time-stamp">üïí${timeStamp}. </span>`;
                }

                const cost = QuokkaCostEstimator.estimateCost(message);
                if (cost) {
                    metadataParagraph.innerHTML += `<span class="price">üí∞Cost: $${cost.costTotal.toFixed(3)} ($${cost.costIn?.toFixed(6) ?? 'n/a'} in, $${cost.costOut?.toFixed(6) ?? 'n/a'} out)</span>`;
                }

                this.#answerDiv.append(metadataParagraph);
            }

            renderTotalCost() {
                const estimatedMessages = this.#chat.conversationHistory
                    .map(m => QuokkaCostEstimator.estimateCost(m))
                    .filter(c => c);

                if (estimatedMessages.length === 0) {
                    return;
                }

                const totalCost = estimatedMessages.reduce((acc, c) => {
                    acc.costIn += c.costIn;
                    acc.costOut += c.costOut;
                    acc.costTotal += c.costTotal;
                    return acc;
                }, { costIn: 0, costOut: 0, costTotal: 0 });

                if (this.#totalCostParagraph) {
                    this.#totalCostParagraph.remove();
                }

                this.#totalCostParagraph = document.createElement('p');
                this.#totalCostParagraph.classList.add('metadata');
                this.#totalCostParagraph.innerHTML = `Estimated total conversation cost: $${totalCost.costTotal.toFixed(3)} ($${totalCost.costIn.toFixed(6)} in, $${totalCost.costOut.toFixed(6)} out)`;
                this.#answerDiv.append(this.#totalCostParagraph);
            }

            scrollToBottom() {
                setTimeout(() => {
                    this.#answerDiv.scrollTop = this.#answerDiv.scrollHeight;
                });
            }
        }

        class QuokkaTool {
            constructor(name, description, url, parametersSchema, active) {
                this.name = name;
                this.description = description;
                this.url = url;
                this.parametersSchema = parametersSchema;
                this.active = active;
            }

            toOpenAIModel(toolCompatMode) {
                const result = {
                    type: 'function',
                    function: {
                        name: this.name,
                        description: this.description
                    }
                };

                if (this.parametersSchema) {
                    result.function.parameters = this.parametersSchema;

                    // TODO: remove this compatibility for LocalAI
                    if (toolCompatMode) {
                        // scan only one level of properties for now
                        Object.entries(result.function.parameters.properties).forEach(([key, value]) => {
                            if (value.type === 'object' && !value.properties) {
                                value.type = 'string';
                            }
                        });
                    }

                } else if (toolCompatMode) { // compatibility mode for LocalAI
                    result.function.parameters = {
                        "type": "object",
                        "properties": {
                            "i": {
                                "type": "number",
                                "description": "i"
                            }
                        },
                        "required": []
                    };
                }

                return result;
            }
        }

        const chatModelList = [
            {
                groupName: 'OpenAI',
                models: [ 'gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo-preview', 'gpt-4', 'gpt-3.5-turbo', 'gpt-4-vision-preview', 'gpt-4-32k', 'o1-preview', 'o1-mini', 'o1', 'o3-mini', 'gpt-5', 'gpt-5-mini', 'gpt-5-nano', 'gpt-5-pro', 'gpt-5.1-2025-11-13', 'gpt-4.1', 'o3-deep-research', 'o4-mini-deep-research', 'o4-mini', 'gpt-5-codex'],
                baseUrl: 'https://api.openai.com/v1/chat/completions',
            },
            {
                groupName: 'LocalAI',
                models: ['gpt-4', 'gpt-4-vision-preview'],
                baseUrl: 'http://localhost:8080/v1/chat/completions',
            }
        ];

        const imageModelList = [
            {
                groupName: 'OpenAI',
                models: ['dall-e-3', 'dall-e-2', 'gpt-image-1', 'gpt-image-1-mini'],
                baseUrl: 'https://api.openai.com/v1/images/generations',
            },
            {
                groupName: 'LocalAI',
                models: ['stablediffusion'],
                baseUrl: 'http://localhost:8080/v1/images/generations',
            }
        ];

        const modelSearchIndex = {};

        function fillModelSelect(selectElement, modelGroups) {
            modelGroups.forEach(group => {
                const optGroup = document.createElement('optgroup');
                optGroup.label = group.groupName;
                selectElement.add(optGroup);

                group.models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = `${group.groupName}/${model}`;
                    option.text = model;
                    selectElement.add(option);

                    modelSearchIndex[`${group.groupName}/${model}`] = { group, model };
                });
            });
        }

        function init() {
            userSelect = document.getElementById('userSelect');
            loadingElement = document.getElementById('loading');
            mainInput = document.getElementById('mainInput');
            chatsHistoryContainer = document.getElementById('chatsHistory');
            storageStatsDiv = document.getElementById('storageStats');
            chatNameInput = document.getElementById('chatNameInput');
            tokensLimitInput = document.getElementById('tokensLimitInput');
            chatModelSelect = document.getElementById('chatModelSelect');
            imageModelSelect = document.getElementById('imageModelSelect');
            temperatureInput = document.getElementById('temperatureInput');
            topPInput = document.getElementById('topPInput');
            frequencyPenaltyInput = document.getElementById('frequencyPenaltyInput');
            presencePenaltyInput = document.getElementById('presencePenaltyInput');
            seedInput = document.getElementById('seedInput');
            versionElement = document.querySelector('.version');
            toolsListContainer = document.getElementById('toolsList');


            fillModelSelect(chatModelSelect, chatModelList);
            fillModelSelect(imageModelSelect, imageModelList);

            currentChat = new QuokkaChat();
            chatRenderer = new QuokkaChatRenderer(document.getElementById('answer'));
            chatRenderer.selectChat(currentChat);
            nextMessageRole = OpenAiMessageRoles.user;

            tools = [];
            builtInTools = [
                new QuokkaTool(
                    'built_in_generate_image',
                    'Generate image based on text prompt and show it to user in conversation',
                    null,
                    {
                        type: 'object',
                        properties: { prompt: { type: 'string', description: 'Prompt for the image generation' } },
                        required: ['prompt']
                    },
                    false
                ),
                new QuokkaTool(
                    'built_in_get_date_time',
                    'Get current date and time',
                    null,
                    null,
                    false
                ),
                new QuokkaTool(
                    'built_in_integrate_tool',
                    'Integrate external tool into the conversation',
                    null,
                    {
                        type: 'object',
                        properties: {
                            toolName: { type: 'string', description: 'Name of the tool to integrate, preferably in format my_new_tool' },
                            toolDescription: { type: 'string', description: 'Description of the tool' },
                            toolUrl: { type: 'string', description: 'URL to the tool in the format http://mytool.com/{parameter1}/{parameter2}?key={key}&key2={key2}' },
                            parametersSchema: { type: 'object', description: 'JSON schema object for the tool parameters' }
                        },
                        required: ['toolName', 'toolDescription', 'toolUrl']
                    },
                    false
                )
            ];

            users = JSON.parse(localStorage.getItem(localStorageUsersKey)) ?? [];

            handleEvents();

            updateUsers();

            const conn = indexedDB.open('quokkaDb', 5);

            conn.onupgradeneeded = (e) => {
                db = conn.result;
                const oldVersion = e.oldVersion;

                console.log(`Upgrading IndexedDB from oldVersion ${oldVersion} to version ${db.version}`);

                if (oldVersion < 1) {
                    // Initial schema
                    db.createObjectStore('chats', { keyPath: 'id' });
                    console.log('IndexedDB schema v1 applied');
                }

                if (oldVersion < 2) { // v1 -> v2
                    db.deleteObjectStore('chats');
                    db.createObjectStore('chats', { keyPath: 'id', autoIncrement: true });
                    console.log('IndexedDB schema v2 applied, all data wiped, no migration');
                }

                if (oldVersion < 3) { // v2 -> v3
                    // change all chats to use _name instead of name
                    const t = conn.transaction;
                    const store = t.objectStore('chats');
                    const query = store.getAll();
                    query.onsuccess = () => {
                        query.result?.forEach(ch => {
                            ch = migrateChatData(ch, 2, 3);
                            store.put(ch);
                        });

                        console.log('IndexedDB schema v3 applied, all data migrated');
                    };
                    query.onerror = (e) => {
                        console.error('Failed to migrate chats to schema v3', error);
                        alert('Failed to migrate chats to schema v3, see console');
                        conn.transaction.abort();
                    };
                }

                if (oldVersion < 4) { // v3 -> v4
                    // add tools to the schema
                    db.createObjectStore('tools', { keyPath: 'name' });
                    console.log('IndexedDB schema v4 applied');
                }

                if (oldVersion < 5) { // v4 -> v5
                    // this is fake version to remove invalid users
                    users = users.filter(u => u.name && u.openAIToken);
                    updateUsers();
                    console.log('IndexedDB schema v5 applied');
                }
            };

            conn.onsuccess = () => {
                db = conn.result;
                console.log('IndexedDB opened successfully, conversations will be recorded');
                versionElement.innerHTML += `, DB v${db.version}`;

                const t = db.transaction('tools', 'readonly');
                const store = t.objectStore('tools');

                const query = store.getAll();
                query.onsuccess = () => {
                    tools = query.result?.map(t => new QuokkaTool(t.name, t.description, t.url, t.parametersSchema, t.active)) ?? [];
                    console.log('Tools loaded from IndexedDB', tools);
                };

                query.onerror = (e) => {
                    console.error('Failed to load tools from IndexedDB', e);
                    alert('Failed to load tools from IndexedDB, see console');
                };
            };

            conn.onerror = (e) => {
                console.error("IndexedDB opening failed, some functionality may be broken!", e);
                alert("Failed to open IndexedDB, see console");
            };
        }

        // TODO move to separate "DB" handling class
        function migrateChatData(chat, sourceVersion, targetVersion) {
            if (sourceVersion < 3 && targetVersion >= 3) {
                chat._name = chat.name;
                delete chat.name;
            }
            return chat;
        }

        function sendChat(skipInput) {
            if (!currentUser) {
                alert('No user selected');
                return;
            }

            if (!skipInput) {
                const prompt = mainInput.value;
                currentChat.addMessage(nextMessageRole, prompt, QuokkaMessageTypes.chat);
            }

            if (nextMessageRole === OpenAiMessageRoles.system) {
                mainInput.value = '';
                toggleMessageRole(OpenAiMessageRoles.user);
                return;
            }

            const model = modelSearchIndex[chatModelSelect.value];
            const apiUrl = model?.group?.baseUrl || 'https://api.openai.com/v1/chat/completions';
            const requestData = {
                model: model?.model,
                messages: currentChat.conversationHistory
                    .filter(m => m.type !== QuokkaMessageTypes.image)
                    .map(m => m.toOpenAIModel()),
                temperature: +temperatureInput?.value || 1,
                max_completion_tokens: +tokensLimitInput?.value || 1024,
                top_p: +topPInput?.value || 1,
                frequency_penalty: +frequencyPenaltyInput?.value || 0,
                presence_penalty: +presencePenaltyInput?.value || 0,
                seed: +seedInput?.value || null
            };

            // TODO: remove this when LocalAI is fully compatible with OpenAI
            const toolCompatMode = model?.group?.groupName === 'LocalAI';
            const availableTools = [...builtInTools, ...tools].filter(t => t.active).map(t => t.toOpenAIModel(toolCompatMode));
            if (availableTools.length > 0) {
                requestData.tools = availableTools;
            }

            const headers = {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentUser.openAIToken}`,
            };

            setLoading(true);
            fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestData),
            })
                .then((response) => response.json())
                .then((data) => {
                    console.log(data);

                    data?.choices?.forEach((choice, index) => {
                        const isFirst = index === 0;
                        const content = choice?.message?.content || (choice?.message?.tool_calls ? 'I decided to call available tools:' : null);
                        currentChat.addMessage(choice?.message?.role, content, QuokkaMessageTypes.chat,
                            isFirst ? data?.model : null, isFirst ? data?.usage : null, choice?.finish_reason);

                        choice?.message?.tool_calls?.forEach(toolCall => {
                            const toolType = toolCall?.type;
                            const toolCallId = toolCall?.id;
                            if (toolType === 'function') {
                                currentChat.addMessage(choice?.message?.role, null,
                                    QuokkaMessageTypes.toolCall, null, null, null, null,
                                    { toolCallId, type: 'function', name: toolCall?.function?.name, arguments: toolCall?.function?.arguments });
                                // TODO: tool call "question" and "answer" need to be saved in order
                                // means if two tools are called, the first tool call "question" and "answer" should be saved before the second tool call "question" and "answer"

                                const parsedArguments = JSON.parse(toolCall?.function?.arguments);

                                const toolMatch = [...builtInTools, ...tools].find(t => t.name === toolCall?.function?.name && t.active);

                                if (toolMatch && toolMatch.name === 'built_in_generate_image') {
                                    const prompt = parsedArguments?.prompt;

                                    if (prompt) {
                                        currentChat.addMessage(OpenAiMessageRoles.tool, 'Image generation commenced', QuokkaMessageTypes.toolCall, null, null, null, null, { toolCallId });
                                        currentChat.addMessage(OpenAiMessageRoles.system, `Generating image based on prompt: ${prompt}`, QuokkaMessageTypes.chat);

                                        setTimeout(() => {
                                            mainInput.value = prompt;
                                            generateImage();
                                        });
                                    } else {
                                        currentChat.addMessage(OpenAiMessageRoles.tool, 'No prompt provided for image generation', QuokkaMessageTypes.toolCall, null, null, null, null, { toolCallId });
                                    }
                                    return;
                                }

                                if (toolMatch && toolMatch.name === 'built_in_get_date_time') {
                                    setTimeout(() => {
                                        const now = new Date().toLocaleString();
                                        currentChat.addMessage(OpenAiMessageRoles.tool, now, QuokkaMessageTypes.toolCall, null, null, null, null, { toolCallId });
                                        sendChat(true);
                                    });
                                    return;
                                }

                                if (toolMatch && toolMatch.name === 'built_in_integrate_tool') {
                                    const toolName = parsedArguments?.toolName;
                                    const toolDescription = parsedArguments?.toolDescription;
                                    const toolUrl = parsedArguments?.toolUrl;
                                    const parametersSchema = parsedArguments?.parametersSchema;

                                    setTimeout(() => {
                                        if (toolName && toolDescription && toolUrl) {
                                            const newTool = new QuokkaTool(toolName, toolDescription, toolUrl, parametersSchema, false);
                                            tools.push(newTool);
                                            saveCurrentTools();
                                            currentChat.addMessage(OpenAiMessageRoles.tool, `Tool ${toolName} integrated successfully`, QuokkaMessageTypes.toolCall, null, null, null, null, { toolCallId });
                                        } else {
                                            currentChat.addMessage(OpenAiMessageRoles.tool, 'Failed to integrate tool, missing required parameters', QuokkaMessageTypes.toolCall, null, null, null, null, { toolCallId });
                                        }
                                        sendChat(true);
                                    });
                                    return;
                                }

                                if (toolMatch && toolMatch.url) {
                                    // TODO: consider using tagged template literals if possible
                                    let finalUrl = toolMatch.url;
                                    if (parsedArguments) {
                                        for (const [key, value] of Object.entries(parsedArguments)) {
                                            finalUrl = finalUrl.replace(`{${key}}`, value, 'g');
                                        }
                                    }
                                    fetch(finalUrl)
                                        .then(response => response.json())
                                        .then(data => {
                                            const result = JSON.stringify(data);
                                            currentChat.addMessage(OpenAiMessageRoles.tool, result, QuokkaMessageTypes.toolCall, null, null, null, null, { toolCallId });
                                            sendChat(true);
                                        });
                                    return;
                                }

                                currentChat.addMessage(OpenAiMessageRoles.tool, 'Requested tool not found.', QuokkaMessageTypes.toolCall, null, null, null, null, { toolCallId });
                                sendChat(true);
                            }
                        });
                    });
                    mainInput.value = '';
                })
                .catch((error) => {
                    alert('An error occured, see console');
                    console.error('Error:', error);
                }).finally(() => {
                    setLoading(false);
                });
        }

        function generateImage() {
            if (!currentUser) {
                alert('No user selected');
                return;
            }

            const imageSizeSelect = document.getElementById('imageSizeSelect');
            const imageDisableRevisedPromptCb = document.getElementById('imageDisableRevisedPromptCb');
            const imageQualitySelect = document.getElementById('imageQualitySelect');
            const imageStyleSelect = document.getElementById('imageStyleSelect');
            const imageOutputFormatSelect = document.getElementById('imageOutputFormatSelect');
            const imageBackgroundSelect = document.getElementById('imageBackgroundSelect');
            const imageCompressionInput = document.getElementById('imageCompressionInput');

            let prompt = mainInput.value;
            if (imageDisableRevisedPromptCb.checked) {
                // "disabling" from the docs
                prompt = 'I NEED to test how the tool works with extremely simple prompts. DO NOT add any detail, just use it AS-IS: ' + prompt;
            }

            currentChat.addMessage('user', prompt, QuokkaMessageTypes.image);

            const model = modelSearchIndex[imageModelSelect.value];
            const apiUrl = model?.group?.baseUrl || 'https://api.openai.com/v1/images/generations';
            const imageModel = model?.model;
            const imageSize = imageSizeSelect.value;
            const requestData = {
                model: imageModel,
                prompt: prompt,
                n: 1,
                size: imageSize
            };

            // Check if model is gpt-image-1 or gpt-image-1-mini
            const isGptImage = imageModel && (imageModel.startsWith('gpt-image-1'));

            // For gpt-image-1, don't send response_format as it always returns base64
            // For other models, use b64_json since fetch by URL is blocked by CORS
            if (!isGptImage && imageModel !== 'stablediffusion') {
                requestData.response_format = 'b64_json';
            }

            // TODO: remove hack for LocalAI
            if (imageModel === 'stablediffusion') {
                delete requestData.n;
            }

            // Handle quality parameter based on model
            const quality = imageQualitySelect.value;
            if (quality) {
                requestData.quality = quality;
            }

            // Handle style parameter (only for dall-e-3)
            if (imageStyleSelect.value) {
                requestData.style = imageStyleSelect.value;
            }

            // Handle gpt-image-1 specific parameters
            if (isGptImage) {
                // Output format
                const outputFormat = imageOutputFormatSelect.value;
                if (outputFormat) {
                    requestData.output_format = outputFormat;
                }

                // Background
                const background = imageBackgroundSelect.value;
                if (background) {
                    requestData.background = background;
                }

                // Compression (only for webp/jpeg)
                const compression = parseInt(imageCompressionInput.value);
                const format = outputFormat || 'png';
                if (format === 'webp' || format === 'jpeg') {
                    if (compression >= 0 && compression <= 100) {
                        requestData.output_compression = compression;
                    }
                }
            }

            const headers = {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentUser.openAIToken}`,
            };

            setLoading(true);
            fetch(apiUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestData),
            })
                .then((response) => response.json())
                .then((response) => {
                    console.log(response);

                    response?.data?.forEach(img => {
                        if (img.b64_json) {
                            // Determine the correct MIME type based on output_format
                            const outputFormat = requestData.output_format || 'png';
                            const mimeType = outputFormat === 'jpeg' ? 'image/jpeg' : 
                                           outputFormat === 'webp' ? 'image/webp' : 'image/png';
                            const blob = convertBase64ToBlob(img.b64_json, mimeType);

                            currentChat.addMessage('assistant', blob, QuokkaMessageTypes.image, imageModel, null, null, {
                                size: imageSize,
                                quality: requestData.quality
                            });
                        }

                        if (img.url) {
                            currentChat.addMessage('assistant', `Image URL: <a href="${img.url}" target="_blank"><img src="${img.url}" /><br />${img.url}</a>`, QuokkaMessageTypes.image);
                        }

                        if (img.revised_prompt) {
                            currentChat.addMessage('assistant', `Revised prompt: <em>${img.revised_prompt}</em>`, QuokkaMessageTypes.image);
                        }
                    });
                    mainInput.value = '';
                })
                .catch((error) => {
                    console.error('Error:', error);
                }).finally(() => {
                    setLoading(false);
                });
        }

        function convertBase64ToBlob(base64, type) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: type });
        }

        async function convertBlobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function toggleMessageRole(nextRoleOverride) {
            const rolesAvailable = [OpenAiMessageRoles.user, OpenAiMessageRoles.assistant, OpenAiMessageRoles.system];
            const currentRoleIndex = rolesAvailable.indexOf(nextMessageRole);
            nextMessageRole = nextRoleOverride || rolesAvailable[(currentRoleIndex + 1) % rolesAvailable.length];

            const messageRoleSwitcher = document.getElementById('messageRoleSwitcher');
            messageRoleSwitcher.innerText = nextMessageRole[0].toUpperCase();
            messageRoleSwitcher.title = `Next mesage will be under role '${nextMessageRole}'`;
        }

        function addUser() {
            const name = prompt('Name?') || '(no name)';
            const openAIToken = prompt('OpenAI token?') || '(no token)';

            users = [...users, { name: name, openAIToken: openAIToken }];
            updateUsers();
        }

        function clearUsers() {
            if (!confirm('Are you sure you want to clear all users?')) {
                return;
            }

            users = [];
            updateUsers();
        }

        function deleteUser() {
            if (!currentUser) {
                alert('No user selected');
                return;
            }

            if (!confirm(`Are you sure you want to delete user ${currentUser?.name}?`)) {
                return;
            }

            users = users.filter(u => u !== currentUser);
            updateUsers();
        }

        function updateUsers() {
            localStorage.setItem(localStorageUsersKey, JSON.stringify(users));
            renderUsers();

            setCurrentUser();
        }

        function setCurrentUser() {
            currentUser = users.find(u => u.name === userSelect.value);
        }

        function renderUsers() {
            userSelect.innerHTML = '';

            users?.forEach(u => {
                userSelect.innerHTML += `<option value="${u.name}">${u.name}</option>`;
            });
        }

        function addTool() {
            renderTool();
        }

        function renderTool(existingTool, isBuiltIn = false) {
            const activeCb = document.createElement('input');
            activeCb.type = 'checkbox';
            activeCb.title = 'Active/Inactive tool, when inactive, it reduces amount of tokens sent = cost of the chat';
            activeCb.checked = existingTool?.active;

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.placeholder = 'Tool name (unique)';
            nameInput.value = existingTool?.name ?? '';

            const urlInput = document.createElement('input');
            urlInput.type = 'text';
            urlInput.placeholder = 'Tool URL';
            urlInput.value = existingTool?.url ?? '';

            const descriptionInput = document.createElement('textarea');
            descriptionInput.placeholder = 'Tool description';
            descriptionInput.rows = 3;
            descriptionInput.value = existingTool?.description ?? '';

            const paramsInput = document.createElement('textarea');
            paramsInput.placeholder = 'Tool parameters (JSON schema)';
            paramsInput.rows = 3;
            paramsInput.value = existingTool?.parametersSchema ? JSON.stringify(existingTool.parametersSchema) : null;

            if (isBuiltIn) {
                nameInput.disabled = true;
                urlInput.disabled = true;
            }

            const saveButton = document.createElement('button');
            saveButton.innerText = 'Save';

            const cancelButton = document.createElement('button');
            cancelButton.innerText = 'Cancel';

            const deleteButton = document.createElement('button');
            deleteButton.innerText = 'Delete';

            const toolDiv = document.createElement('div');
            toolDiv.append(activeCb, nameInput, urlInput, descriptionInput, paramsInput, saveButton, cancelButton);
            if (!isBuiltIn) {
                toolDiv.append(deleteButton);
            }
            toolsListContainer.append(toolDiv);

            saveButton.onclick = () => {
                const name = nameInput.value;
                const url = urlInput.value;
                const description = descriptionInput.value;
                let params;
                try {
                    params = paramsInput.value ? JSON.parse(paramsInput.value) : null;
                } catch (error) {
                    alert('Invalid JSON in parameters');
                    return;
                }
                const active = activeCb.checked;

                if (!name || (!url && !isBuiltIn)) {
                    alert('Name and URL are required');
                    return;
                }

                const duplicateNameTool = [...builtInTools, ...tools].find(t => t.name === name && t !== existingTool);
                if (duplicateNameTool) {
                    alert('Tool with this name already exists');
                    return;
                }

                if (existingTool) {
                    // update existing tool
                    existingTool.name = name;
                    existingTool.url = url;
                    existingTool.description = description;
                    existingTool.parametersSchema = params;
                    existingTool.active = active;

                    saveCurrentTools();

                    toolDiv.remove();
                    renderTools();
                    return;
                }

                tools.push(new QuokkaTool(name, description, url, params, active));
                saveCurrentTools();

                toolDiv.remove();
                renderTools();
            };

            cancelButton.onclick = () => {
                if (!existingTool) {
                    toolDiv.remove();
                }
            };

            deleteButton.onclick = () => {
                if (!confirm('Are you sure you want to delete this tool?')) {
                    return;
                }

                const index = tools.indexOf(existingTool);
                if (index > -1) {
                    tools.splice(index, 1);
                    saveCurrentTools();
                    renderTools();
                }
            };
        }

        function renderTools() {
            toolsListContainer.innerHTML = '';

            builtInTools?.forEach(t => {
                renderTool(t, true);
            });

            tools?.forEach(t => {
                renderTool(t);
            });
        }

        function saveCurrentTools() {
            const t = db.transaction('tools', 'readwrite');
            const store = t.objectStore('tools');

            const clearQuery = store.clear();
            clearQuery.onsuccess = () => {
                tools.forEach(t => {
                    store.put(t);
                });
            };
            clearQuery.onerror = (e) => {
                console.error('Failed to clear tools from IndexedDB', e);
                alert('Failed to clear tools from IndexedDB, see console');
            };
        }

        function renderChatsHistory() {
            chatsHistoryContainer.innerHTML = '';

            const t = db.transaction('chats', 'readonly');
            const store = t.objectStore('chats');

            const query = store.getAll();
            query.onsuccess = () => {
                query.result?.forEach(ch => {
                    // TODO: transform to QuokkaChat or move to separate storage class
                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('emoji');
                    deleteBtn.innerText = '‚ùå';
                    deleteBtn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); onChatHistoryDelete(ch); return false; };

                    const chatHistoryPar = document.createElement('p');
                    const numberOfMessages = ch?.conversationHistory?.filter(m => m.type === QuokkaMessageTypes.chat)?.length;
                    const numberOfImages = ch?.conversationHistory?.filter(m => m.type === QuokkaMessageTypes.image)?.length;
                    chatHistoryPar.innerHTML = `${ch.id}: <span>${ch._name} (${numberOfMessages} messages, ${numberOfImages} image messages)</span>`;
                    chatHistoryPar.append(deleteBtn);
                    chatHistoryPar.onclick = () => { onChatHistorySelect(ch); };

                    chatsHistoryContainer.append(chatHistoryPar);
                });
            };
            query.onerror = (e) => {
                console.error('Failed to get chats history from IndexedDB', error);
                alert('Failed to get chats history from IndexedDB, see console');
            };
        }

        function renderStorageStats() {
            if (navigator?.storage?.estimate) {
                navigator.storage.estimate().then(estimate => {
                    const formattedUsage = (estimate.usage / 1024 / 1024).toFixed(2);
                    const formattedQuota = (estimate.quota / 1024 / 1024).toFixed(2);
                    const warningThreshold = 200; // MB
                    storageStatsDiv.innerHTML = `<p>Used storage: ~${formattedUsage} MB / ${warningThreshold} MB warning threshold / quota ${formattedQuota} MB</p>`;
                    const usagePercentage = (estimate.usage / 1024 / 1024 / warningThreshold) * 100; // 200MB warning threshold

                    const usageBarBackground = document.createElement('div');
                    usageBarBackground.classList.add('usage-bar-background');
                    const usageBar = document.createElement('div');
                    usageBar.classList.add('usage-bar');
                    usageBar.style.width = `${usagePercentage}%`;
                    usageBar.style.backgroundColor = usagePercentage > 90 ? 'red' : usagePercentage > 50 ? 'orange' : 'green';
                    usageBarBackground.append(usageBar);
                    storageStatsDiv.append(usageBarBackground);
                });
            }
        }

        function onChatHistorySelect(chatHistoryItem) {
            toggleSidebar();
            currentChat = new QuokkaChat( // TODO: move to separate storage class
                chatHistoryItem.id,
                chatHistoryItem._name, // starting from schema v3, name is stored as pseudo-private _name
                chatHistoryItem.conversationHistory?.map(m => new QuokkaMessage(m.role, m.content, m.type, m.model, m.tokenUsage, m.finishReason, m.imageOptions, m.timeStamp, m.toolCallOptions))
            );
            chatRenderer.selectChat(currentChat);
        }

        function onChatHistoryDelete(chatHistoryItem) {
            if (!chatHistoryItem?.id) {
                renderChatsHistory();
                return;
            }

            if (!confirm(`Are you sure you want to delete chat ${chatHistoryItem._name} (id: ${chatHistoryItem.id})?`)) {
                return;
            }

            const t = db.transaction('chats', 'readwrite');
            const store = t.objectStore('chats');

            const query = store.delete(chatHistoryItem.id);
            query.onsuccess = () => {
                console.warn(`Chat Id ${chatHistoryItem.id} deleted`, chatHistoryItem);
                renderChatsHistory();
            };
            query.onerror = (e) => {
                console.error('Failed to delete chat from IndexedDB', error);
                alert('Failed to delete chat from IndexedDB, see console');
            };
        }

        function saveCurrentChat() {
            if (!currentChat) {
                return;
            }

            const t = db.transaction('chats', 'readwrite');
            const store = t.objectStore('chats');

            const saveQuery = store.put(currentChat);

            saveQuery.onsuccess = (event) => {
                currentChat.id = saveQuery.result;
                console.log(`Chat Id ${currentChat.id} saved`, currentChat);

                renderChatsHistory();
            };
            saveQuery.onerror = (e) => {
                console.error('Failed to save chat into IndexedDB', e);
                alert('Failed to save chat into IndexedDB, see console');
            };
        }

        function importData() {
            const file = document.getElementById('importFile').files[0];
            if (!file) {
                alert('No file selected');
                return;
            }

            setLoading(true);
            const reader = new FileReader();
            reader.onload = function (e) {
                const contents = e.target.result;
                const data = JSON.parse(contents);

                if (!data || !data.dbVersion || !data.chats || !Array.isArray(data.chats)) {
                    alert('Invalid JSON file');
                    setLoading(false);
                    return;
                }

                const confirmMessage = `You are about to import ${data.chats.length} chats from file created on ${data.exportDate} from ${data.exportedFrom}. Are you sure?`;
                if (!confirm(confirmMessage)) {
                    setLoading(false);
                    return;
                }

                let migratedChats = [];
                try {
                    console.log(`Migrating chats from file from version ${data.dbVersion} to current version ${db.version}`);
                    migratedChats = data.chats.map(ch => migrateChatData(ch, data.dbVersion, db.version));
                    migratedChats.forEach(ch => {
                        ch.conversationHistory?.forEach(m => {
                            if (m.type === QuokkaMessageTypes.image && m.content && m.role === 'assistant' && m.content.startsWith('data:image/png;base64,')) {
                                const blob = convertBase64ToBlob(m.content.replace('data:image/png;base64,', ''), 'image/png');
                                m.content = blob;
                            }
                        });
                    });
                } catch (error) {
                    console.error('Failed to migrate chats from file', error);
                    alert('Failed to migrate chats from file, see console');
                    setLoading(false);
                    return;
                }

                const overwriteChats = document.getElementById('overwriteChatsCb').checked;
                if (!overwriteChats) {
                    migratedChats.forEach(ch => delete ch.id);
                }

                const t = db.transaction('chats', 'readwrite');
                const store = t.objectStore('chats');

                migratedChats.forEach(ch => {
                    store.put(ch);
                });

                t.oncomplete = () => {
                    console.log('Imported chats', migratedChats);
                    renderChatsHistory();
                    setLoading(false);
                };

                t.onerror = (e) => {
                    console.error('Failed to import chats into IndexedDB', e);
                    alert('Failed to import chats into IndexedDB, see console');
                    setLoading(false);
                };
            };
            reader.readAsText(file);
        }

        async function exportData() {
            const data = {
                dbVersion: db.version,
                exportDate: new Date().toISOString(),
                exportedFrom: location.href,
                chats: []
            };

            const t = db.transaction('chats', 'readonly');
            const store = t.objectStore('chats');

            setLoading(true);
            const query = store.getAll();
            query.onsuccess = async () => {
                data.chats = query.result;

                for await (const ch of data.chats) {
                    for await (const m of ch?.conversationHistory) {
                        if (m.type === QuokkaMessageTypes.image && m.content instanceof Blob) {
                            const base64 = await convertBlobToBase64(m.content);
                            m.content = base64;
                        }
                    }
                }

                const dataStr = JSON.stringify(data, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                const exportFileDefaultName = 'quokkaData.json';

                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();

                setLoading(false);
            };
            query.onerror = (e) => {
                console.error('Failed to get chats from IndexedDB for export', error);
                alert('Failed to get chats from IndexedDB for export, see console');
                setLoading(false);
            };
        }

        function toggleSidebar() {
            renderTools();
            renderChatsHistory();
            renderStorageStats();
            document.querySelector(".sidebar").classList.toggle("open");
            document.querySelector(".sidebar-overlay").classList.toggle("open");
        }

        function setLoading(isLoading) {
            loadingElement.style.visibility = isLoading ? 'visible' : 'hidden';
            mainInput.disabled = isLoading;
        }

        function handleEvents() {
            document.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.key == "Enter") {
                    sendChat();
                }
            });

            handleRangeSlide(temperatureInput, 'temperatureValue');
            handleRangeSlide(topPInput, 'topPValue');
            handleRangeSlide(frequencyPenaltyInput, 'frequencyPenaltyValue');
            handleRangeSlide(presencePenaltyInput, 'presencePenaltyValue');
            handleRangeSlide(document.getElementById('imageCompressionInput'), 'imageCompressionValue');

            handleSwipe(document.body, (distance) => {
                // swipe right
                if (distance > 100) {
                    toggleSidebar();
                }

                // swipe left
                if (distance < -100) {
                    toggleSidebar();
                }
            });

            handleSwipe(mainInput, (distance, event) => {
                // swipe right
                if (distance > 100) {
                    sendChat();
                    event.stopPropagation();
                }
            });
        }

        function handleRangeSlide(rangeInput, valueInputId) {
            rangeInput.oninput = () => {
                document.getElementById(valueInputId).value = rangeInput.value;
            };
        }

        function handleSwipe(targetElement, callback) {
            let touchStartX = 0;
            let touchEndX = 0;

            targetElement.addEventListener('touchstart', (event) => {
                touchStartX = event.changedTouches?.[0]?.screenX;
                touchEndX = touchStartX; // prevent issue with taps, no touchmove event
            });

            targetElement.addEventListener('touchmove', (event) => {
                touchEndX = event.changedTouches?.[0]?.screenX;
            }, { passive: true });

            targetElement.addEventListener('touchend', (event) => {
                const distance = touchEndX - touchStartX; // warning: NaN if no changedTouches
                callback(distance, event);
            });
        }
    </script>

</body>

</html>
